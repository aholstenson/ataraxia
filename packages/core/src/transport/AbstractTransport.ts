import debug from 'debug';
import { Event } from 'atvik';

import { WithNetwork } from '../WithNetwork';

import { Transport } from './Transport';

import { Peer } from './Peer';
import { TransportOptions } from './TransportOptions';
import { IdMap, compareId, encodeId } from '../id';
import { isMergeablePeer } from './MergeablePeer';

/**
 * Abstract base for implementing transports. Implements common behavior to
 * help with tracking of peers.
 */
export class AbstractTransport
	implements Transport
{
	private readonly transportName: string;

	private readonly peerConnectEvent: Event<this, [ Peer ]>;
	private readonly peerDisconnectEvent: Event<this, [ Peer ]>;

	protected debug: debug.Debugger;

	private _started: boolean;

	private _network?: WithNetwork;
	protected readonly peers: Set<Peer>;

	constructor(name: string) {
		this.peerConnectEvent = new Event(this);
		this.peerDisconnectEvent = new Event(this);

		this.peers = new Set();

		this._started = false;
		this.transportName = name;
		this.debug = debug('ataraxia:no-network:' + name);
	}

	/**
	 * Event for when a new peer is connected via this transport.
	 */
	get onPeerConnect() {
		return this.peerConnectEvent.subscribable;
	}

	/**
	 * Event for when a peer is disconnected.
	 */
	get onPeerDisconnect() {
		return this.peerDisconnectEvent.subscribable;
	}

	/**
	 * Get if transport is started.
	 */
	get started() {
		return this._started;
	}

	/**
	 * Get the network of this transport.
	 */
	protected get network(): WithNetwork {
		if(! this._network) {
			throw new Error('Can\'t access network before start() is called');
		}

		return this._network;
	}

	/**
	 * Start this transport.
	 *
	 * @param {object} options
	 *   Options as generated by the network instance. Contains `id` which is
	 *   a generated id of the local peer, `name` which is the short name of
	 *   the network (used for things such as discovery) and `endpoint` which
	 *   is a boolean indicating if the network wants to perform routing.
	 * @returns
	 *   Boolean indicating if the transport was started.
	 */
	public async start(options: TransportOptions): Promise<boolean> {
		if(this._started) {
			return false;
		}

		this.debug = debug('ataraxia:' + options.networkName + ':' + this.transportName);
		this._started = true;

		this.debug('Starting with id ' + encodeId(options.networkId));

		this._network = {
			networkId: options.networkId,
			debugNamespace: this.debug.namespace
		};

		return true;
	}

	/**
	 * Stop this transport.
	 *
	 * @returns
	 *   Boolean indicating if the transport was stopped.
	 */
	public async stop(): Promise<boolean> {
		if(! this._started) {
			return false;
		}

		for(const peer of this.peers.values()) {
			peer.disconnect();
		}

		this._started = false;
		return true;
	}

	/**
	 * Add a peer to this transport.
	 *
	 * @param {Peer} peer
	 */
	protected addPeer(peer: Peer) {
		const onConnect = () => {
			// New peer, connect to it
			this.peers.add(peer);

			this.debug('Peer with id', encodeId(peer.id), 'is now available');
			this.peerConnectEvent.emit(peer);
		};

		peer.onConnect(onConnect);

		peer.onDisconnect(() => {
			this.peers.delete(peer);

			this.debug('Peer with id', encodeId(peer.id), 'is no longer available');
			this.peerDisconnectEvent.emit(peer);
		});

		if(peer.connected) {
			// If adding an already connected peer run connect routine
			onConnect();
		}
	}
}
